{"ast":null,"code":"import { drawing as draw, geometry } from '@progress/kendo-drawing';\nimport PieSegment from './pie-segment';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport { ChartElement, Ring, Box, Point } from '../../core';\nimport { OUTSIDE_END, FADEIN, COLUMN } from '../constants';\nimport { bindSegments, evalOptions } from '../utils';\nimport { CIRCLE, RIGHT, CENTER } from '../../common/constants';\nimport { deepExtend, defined, find, isFunction, last, round, setDefaultOptions, valueOrDefault } from '../../common';\nvar PIE_SECTOR_ANIM_DELAY = 70;\n\nvar PieChart = function (ChartElement) {\n  function PieChart(plotArea, options) {\n    ChartElement.call(this, options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this.points = [];\n    this.legendItems = [];\n    this.render();\n  }\n\n  if (ChartElement) PieChart.__proto__ = ChartElement;\n  PieChart.prototype = Object.create(ChartElement && ChartElement.prototype);\n  PieChart.prototype.constructor = PieChart;\n\n  PieChart.prototype.render = function render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  };\n\n  PieChart.prototype.traverseDataPoints = function traverseDataPoints(callback) {\n    var this$1 = this;\n    var ref = this;\n    var options = ref.options;\n    var seriesColors = ref.plotArea.options.seriesColors;\n    if (seriesColors === void 0) seriesColors = [];\n    var colorsCount = seriesColors.length;\n    var series = options.series;\n    var seriesCount = series.length;\n\n    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      var currentSeries = series[seriesIx];\n      var data = currentSeries.data;\n      var ref$1 = bindSegments(currentSeries);\n      var total = ref$1.total;\n      var points = ref$1.points;\n      var count = ref$1.count;\n      var anglePerValue = 360 / total;\n      var constantAngle = void 0;\n\n      if (!isFinite(anglePerValue)) {\n        constantAngle = 360 / count;\n      }\n\n      var currentAngle = void 0;\n\n      if (defined(currentSeries.startAngle)) {\n        currentAngle = currentSeries.startAngle;\n      } else {\n        currentAngle = options.startAngle;\n      }\n\n      if (seriesIx !== seriesCount - 1) {\n        if (currentSeries.labels.position === OUTSIDE_END) {\n          currentSeries.labels.position = CENTER;\n        }\n      }\n\n      for (var i = 0; i < points.length; i++) {\n        var pointData = points[i];\n\n        if (!pointData) {\n          continue;\n        }\n\n        var fields = pointData.fields;\n        var value = pointData.value;\n        var visible = pointData.visible;\n        var angle = value !== 0 ? constantAngle || value * anglePerValue : 0;\n        var explode = data.length !== 1 && Boolean(fields.explode);\n\n        if (!isFunction(currentSeries.color)) {\n          currentSeries.color = fields.color || seriesColors[i % colorsCount];\n        }\n\n        callback(pointData.valueFields.value, new Ring(null, 0, 0, currentAngle, angle), {\n          owner: this$1,\n          category: defined(fields.category) ? fields.category : \"\",\n          index: i,\n          series: currentSeries,\n          seriesIx: seriesIx,\n          dataItem: data[i],\n          percentage: total !== 0 ? value / total : 0,\n          explode: explode,\n          visibleInLegend: fields.visibleInLegend,\n          visible: visible,\n          zIndex: seriesCount - seriesIx,\n          animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)\n        });\n\n        if (visible !== false) {\n          currentAngle += angle;\n        }\n      }\n    }\n  };\n\n  PieChart.prototype.evalSegmentOptions = function evalSegmentOptions(options, value, fields) {\n    var series = fields.series;\n    evalOptions(options, {\n      value: value,\n      series: series,\n      dataItem: fields.dataItem,\n      category: fields.category,\n      percentage: fields.percentage\n    }, {\n      defaults: series._defaults,\n      excluded: [\"data\", \"content\", \"template\", \"visual\", \"toggle\"]\n    });\n  };\n\n  PieChart.prototype.addValue = function addValue(value, sector, fields) {\n    var segmentOptions = deepExtend({}, fields.series, {\n      index: fields.index\n    });\n    this.evalSegmentOptions(segmentOptions, value, fields);\n    this.createLegendItem(value, segmentOptions, fields);\n\n    if (fields.visible === false) {\n      return;\n    }\n\n    var segment = new PieSegment(value, sector, segmentOptions);\n    Object.assign(segment, fields);\n    this.append(segment);\n    this.points.push(segment);\n  };\n\n  PieChart.prototype.reflow = function reflow(targetBox) {\n    var ref = this;\n    var options = ref.options;\n    var points = ref.points;\n    var seriesConfigs = ref.seriesConfigs;\n    if (seriesConfigs === void 0) seriesConfigs = [];\n    var count = points.length;\n    var box = targetBox.clone();\n    var space = 5;\n    var minWidth = Math.min(box.width(), box.height());\n    var halfMinWidth = minWidth / 2;\n    var defaultPadding = minWidth - minWidth * 0.85;\n    var newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n    var newBoxCenter = newBox.center();\n    var boxCenter = box.center();\n    var seriesCount = options.series.length;\n    var leftSideLabels = [];\n    var rightSideLabels = [];\n    var padding = valueOrDefault(options.padding, defaultPadding);\n    this.targetBox = targetBox;\n    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n    var radius = halfMinWidth - padding;\n    var center = new Point(radius + newBox.x1 + padding, radius + newBox.y1 + padding);\n\n    for (var i = 0; i < count; i++) {\n      var segment = points[i];\n      var sector = segment.sector;\n      var seriesIndex = segment.seriesIx;\n      sector.radius = radius;\n      sector.center = center;\n\n      if (seriesConfigs.length) {\n        var seriesConfig = seriesConfigs[seriesIndex];\n        sector.innerRadius = seriesConfig.innerRadius;\n        sector.radius = seriesConfig.radius;\n      }\n\n      if (seriesIndex === seriesCount - 1 && segment.explode) {\n        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n      }\n\n      segment.reflow(newBox);\n      var label = segment.label;\n\n      if (label) {\n        if (label.options.position === OUTSIDE_END) {\n          if (seriesIndex === seriesCount - 1) {\n            if (label.orientation === RIGHT) {\n              rightSideLabels.push(label);\n            } else {\n              leftSideLabels.push(label);\n            }\n          }\n        }\n      }\n    }\n\n    if (leftSideLabels.length > 0) {\n      leftSideLabels.sort(this.labelComparator(true));\n      this.leftLabelsReflow(leftSideLabels);\n    }\n\n    if (rightSideLabels.length > 0) {\n      rightSideLabels.sort(this.labelComparator(false));\n      this.rightLabelsReflow(rightSideLabels);\n    }\n\n    this.box = newBox;\n  };\n\n  PieChart.prototype.leftLabelsReflow = function leftLabelsReflow(labels) {\n    var distances = this.distanceBetweenLabels(labels);\n    this.distributeLabels(distances, labels);\n  };\n\n  PieChart.prototype.rightLabelsReflow = function rightLabelsReflow(labels) {\n    var distances = this.distanceBetweenLabels(labels);\n    this.distributeLabels(distances, labels);\n  };\n\n  PieChart.prototype.distanceBetweenLabels = function distanceBetweenLabels(labels) {\n    var segment = last(this.points);\n    var sector = segment.sector;\n    var count = labels.length - 1;\n    var lr = sector.radius + segment.options.labels.distance;\n    var distances = [];\n    var firstBox = labels[0].box;\n    var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n    distances.push(distance);\n\n    for (var i = 0; i < count; i++) {\n      var secondBox = labels[i + 1].box;\n      firstBox = labels[i].box;\n      distance = round(secondBox.y1 - firstBox.y2);\n      distances.push(distance);\n    }\n\n    distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n    distances.push(distance);\n    return distances;\n  };\n\n  PieChart.prototype.distributeLabels = function distributeLabels(distances, labels) {\n    var this$1 = this;\n    var count = distances.length;\n    var left, right, remaining;\n\n    for (var i = 0; i < count; i++) {\n      remaining = -distances[i];\n      left = right = i;\n\n      while (remaining > 0 && (left >= 0 || right < count)) {\n        remaining = this$1._takeDistance(distances, i, --left, remaining);\n        remaining = this$1._takeDistance(distances, i, ++right, remaining);\n      }\n    }\n\n    this.reflowLabels(distances, labels);\n  };\n\n  PieChart.prototype._takeDistance = function _takeDistance(distances, anchor, position, amount) {\n    var result = amount;\n\n    if (distances[position] > 0) {\n      var available = Math.min(distances[position], result);\n      result -= available;\n      distances[position] -= available;\n      distances[anchor] += available;\n    }\n\n    return result;\n  };\n\n  PieChart.prototype.reflowLabels = function reflowLabels(distances, labels) {\n    var this$1 = this;\n    var segment = last(this.points);\n    var sector = segment.sector;\n    var labelOptions = segment.options.labels;\n    var labelsCount = labels.length;\n    var labelDistance = labelOptions.distance;\n    var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n    var boxX;\n    distances[0] += 2;\n\n    for (var i = 0; i < labelsCount; i++) {\n      var label = labels[i];\n      var box = label.box;\n      boxY += distances[i];\n      boxX = this$1.hAlignLabel(box.x2, sector.clone().expand(labelDistance), boxY, boxY + box.height(), label.orientation === RIGHT);\n\n      if (label.orientation === RIGHT) {\n        if (labelOptions.align !== CIRCLE) {\n          boxX = sector.radius + sector.center.x + labelDistance;\n        }\n\n        label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n      } else {\n        if (labelOptions.align !== CIRCLE) {\n          boxX = sector.center.x - sector.radius - labelDistance;\n        }\n\n        label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n      }\n\n      boxY += box.height();\n    }\n  };\n\n  PieChart.prototype.createVisual = function createVisual() {\n    var this$1 = this;\n    var ref = this;\n    var connectors = ref.options.connectors;\n    var points = ref.points;\n    var count = points.length;\n    var space = 4;\n    ChartElement.prototype.createVisual.call(this);\n    this._connectorLines = [];\n\n    for (var i = 0; i < count; i++) {\n      var segment = points[i];\n      var sector = segment.sector;\n      var label = segment.label;\n      var angle = sector.middle();\n      var connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n\n      if (label) {\n        var connectorLine = new draw.Path({\n          stroke: {\n            color: connectorsColor,\n            width: connectors.width\n          },\n          animation: {\n            type: FADEIN,\n            delay: segment.animationDelay\n          }\n        });\n\n        if (label.options.position === OUTSIDE_END) {\n          var box = label.box;\n          var centerPoint = sector.center;\n          var start = sector.point(angle);\n          var middle = new Point(box.x1, box.center().y);\n          var sr = void 0,\n              end = void 0,\n              crossing = void 0;\n          start = sector.clone().expand(connectors.padding).point(angle);\n          connectorLine.moveTo(start.x, start.y); // TODO: Extract into a method to remove duplication\n\n          if (label.orientation === RIGHT) {\n            end = new Point(box.x1 - connectors.padding, box.center().y);\n            crossing = intersection(centerPoint, start, middle, end);\n            middle = new Point(end.x - space, end.y);\n            crossing = crossing || middle;\n            crossing.x = Math.min(crossing.x, middle.x);\n\n            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {\n              sr = sector.center.x + sector.radius + space;\n\n              if (segment.options.labels.align !== COLUMN) {\n                if (sr < middle.x) {\n                  connectorLine.lineTo(sr, start.y);\n                } else {\n                  connectorLine.lineTo(start.x + space * 2, start.y);\n                }\n              } else {\n                connectorLine.lineTo(sr, start.y);\n              }\n\n              connectorLine.lineTo(middle.x, end.y);\n            } else {\n              crossing.y = end.y;\n              connectorLine.lineTo(crossing.x, crossing.y);\n            }\n          } else {\n            end = new Point(box.x2 + connectors.padding, box.center().y);\n            crossing = intersection(centerPoint, start, middle, end);\n            middle = new Point(end.x + space, end.y);\n            crossing = crossing || middle;\n            crossing.x = Math.max(crossing.x, middle.x);\n\n            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {\n              sr = sector.center.x - sector.radius - space;\n\n              if (segment.options.labels.align !== COLUMN) {\n                if (sr > middle.x) {\n                  connectorLine.lineTo(sr, start.y);\n                } else {\n                  connectorLine.lineTo(start.x - space * 2, start.y);\n                }\n              } else {\n                connectorLine.lineTo(sr, start.y);\n              }\n\n              connectorLine.lineTo(middle.x, end.y);\n            } else {\n              crossing.y = end.y;\n              connectorLine.lineTo(crossing.x, crossing.y);\n            }\n          }\n\n          connectorLine.lineTo(end.x, end.y);\n\n          this$1._connectorLines.push(connectorLine);\n\n          this$1.visual.append(connectorLine);\n        }\n      }\n    }\n  };\n\n  PieChart.prototype.renderVisual = function renderVisual() {\n    ChartElement.prototype.renderVisual.call(this);\n\n    if (find(this.options.series, function (options) {\n      return options.autoFit;\n    })) {\n      var targetBox = this.targetBox;\n      var pieCenter = this.box.center();\n      var bbox = this.visual.bbox();\n\n      if (!bbox) {\n        return;\n      }\n\n      var bboxBottom = bbox.bottomRight();\n      var scale = Math.min((pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y), (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y), (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x), (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x));\n\n      if (scale < 1) {\n        this.visual.transform(geometry.transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));\n      }\n    }\n  };\n\n  PieChart.prototype.labelComparator = function labelComparator(reverse) {\n    var reverseValue = reverse ? -1 : 1;\n    return function (a, b) {\n      var first = (a.parent.sector.middle() + 270) % 360;\n      var second = (b.parent.sector.middle() + 270) % 360;\n      return (first - second) * reverseValue;\n    };\n  };\n\n  PieChart.prototype.hAlignLabel = function hAlignLabel(originalX, sector, y1, y2, direction) {\n    var radius = sector.radius;\n    var sector_center = sector.center;\n    var cx = sector_center.x;\n    var cy = sector_center.y;\n    var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n\n    if (t > radius) {\n      return originalX;\n    }\n\n    return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);\n  };\n\n  PieChart.prototype.pointInCircle = function pointInCircle(point, center, radius) {\n    return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n  };\n\n  PieChart.prototype.formatPointValue = function formatPointValue(point, format) {\n    return this.chartService.format.auto(format, point.value);\n  };\n\n  PieChart.prototype.animationDelay = function animationDelay(categoryIndex) {\n    return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n  };\n\n  PieChart.prototype.stackRoot = function stackRoot() {\n    return this;\n  };\n\n  return PieChart;\n}(ChartElement);\n\nfunction intersection(a1, a2, b1, b2) {\n  var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n  var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n  var result;\n\n  if (ub !== 0) {\n    var ua = uat / ub;\n    result = new Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y));\n  }\n\n  return result;\n}\n\nsetDefaultOptions(PieChart, {\n  startAngle: 90,\n  connectors: {\n    width: 2,\n    color: \"#939393\",\n    padding: 8\n  },\n  inactiveItems: {\n    markers: {},\n    labels: {}\n  }\n});\ndeepExtend(PieChart.prototype, PieChartMixin);\nPieChart.prototype.isStackRoot = true;\nexport default PieChart;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-chart.js"],"names":["drawing","draw","geometry","PieSegment","PieChartMixin","ChartElement","Ring","Box","Point","OUTSIDE_END","FADEIN","COLUMN","bindSegments","evalOptions","CIRCLE","RIGHT","CENTER","deepExtend","defined","find","isFunction","last","round","setDefaultOptions","valueOrDefault","PIE_SECTOR_ANIM_DELAY","PieChart","plotArea","options","call","chartService","points","legendItems","render","__proto__","prototype","Object","create","constructor","traverseDataPoints","addValue","bind","callback","this$1","ref","seriesColors","colorsCount","length","series","seriesCount","seriesIx","currentSeries","data","ref$1","total","count","anglePerValue","constantAngle","isFinite","currentAngle","startAngle","labels","position","i","pointData","fields","value","visible","angle","explode","Boolean","color","valueFields","owner","category","index","dataItem","percentage","visibleInLegend","zIndex","animationDelay","evalSegmentOptions","defaults","_defaults","excluded","sector","segmentOptions","createLegendItem","segment","assign","append","push","reflow","targetBox","seriesConfigs","box","clone","space","minWidth","Math","min","width","height","halfMinWidth","defaultPadding","newBox","x1","y1","newBoxCenter","center","boxCenter","leftSideLabels","rightSideLabels","padding","translate","x","y","radius","seriesIndex","seriesConfig","innerRadius","setRadius","point","middle","label","orientation","sort","labelComparator","leftLabelsReflow","rightLabelsReflow","distances","distanceBetweenLabels","distributeLabels","lr","distance","firstBox","secondBox","y2","left","right","remaining","_takeDistance","reflowLabels","anchor","amount","result","available","labelOptions","labelsCount","labelDistance","boxY","boxX","hAlignLabel","x2","expand","align","createVisual","connectors","_connectorLines","connectorsColor","connectorLine","Path","stroke","animation","type","delay","centerPoint","start","sr","end","crossing","moveTo","intersection","pointInCircle","lineTo","max","visual","renderVisual","autoFit","pieCenter","bbox","bboxBottom","bottomRight","scale","origin","transform","reverse","reverseValue","a","b","first","parent","second","originalX","direction","sector_center","cx","cy","t","abs","sqrt","pow","formatPointValue","format","auto","categoryIndex","stackRoot","a1","a2","b1","b2","uat","ub","ua","inactiveItems","markers","isStackRoot"],"mappings":"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","sourcesContent":["import { drawing as draw, geometry } from '@progress/kendo-drawing';\n\nimport PieSegment from './pie-segment';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport { ChartElement, Ring, Box, Point } from '../../core';\n\nimport { OUTSIDE_END, FADEIN, COLUMN } from '../constants';\nimport { bindSegments, evalOptions } from '../utils';\n\nimport { CIRCLE, RIGHT, CENTER } from '../../common/constants';\nimport { deepExtend, defined, find, isFunction, last, round, setDefaultOptions, valueOrDefault } from '../../common';\n\nvar PIE_SECTOR_ANIM_DELAY = 70;\n\nvar PieChart = (function (ChartElement) {\n    function PieChart(plotArea, options) {\n        ChartElement.call(this, options);\n\n        this.plotArea = plotArea;\n        this.chartService = plotArea.chartService;\n        this.points = [];\n        this.legendItems = [];\n        this.render();\n    }\n\n    if ( ChartElement ) PieChart.__proto__ = ChartElement;\n    PieChart.prototype = Object.create( ChartElement && ChartElement.prototype );\n    PieChart.prototype.constructor = PieChart;\n\n    PieChart.prototype.render = function render () {\n        this.traverseDataPoints(this.addValue.bind(this));\n    };\n\n    PieChart.prototype.traverseDataPoints = function traverseDataPoints (callback) {\n        var this$1 = this;\n\n        var ref = this;\n        var options = ref.options;\n        var seriesColors = ref.plotArea.options.seriesColors; if ( seriesColors === void 0 ) seriesColors = [];\n        var colorsCount = seriesColors.length;\n        var series = options.series;\n        var seriesCount = series.length;\n\n        for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n            var currentSeries = series[seriesIx];\n            var data = currentSeries.data;\n            var ref$1 = bindSegments(currentSeries);\n            var total = ref$1.total;\n            var points = ref$1.points;\n            var count = ref$1.count;\n            var anglePerValue = 360 / total;\n            var constantAngle = (void 0);\n            if (!isFinite(anglePerValue)) {\n                constantAngle = 360 / count;\n            }\n            var currentAngle = (void 0);\n\n            if (defined(currentSeries.startAngle)) {\n                currentAngle = currentSeries.startAngle;\n            } else {\n                currentAngle = options.startAngle;\n            }\n\n            if (seriesIx !== seriesCount - 1) {\n                if (currentSeries.labels.position === OUTSIDE_END) {\n                    currentSeries.labels.position = CENTER;\n                }\n            }\n\n            for (var i = 0; i < points.length; i++) {\n                var pointData = points[i];\n                if (!pointData) {\n                    continue;\n                }\n\n                var fields = pointData.fields;\n                var value = pointData.value;\n                var visible = pointData.visible;\n                var angle = value !== 0 ? (constantAngle || (value * anglePerValue)) : 0;\n                var explode = data.length !== 1 && Boolean(fields.explode);\n\n                if (!isFunction(currentSeries.color)) {\n                    currentSeries.color = fields.color || seriesColors[i % colorsCount];\n                }\n\n                callback(pointData.valueFields.value, new Ring(null, 0, 0, currentAngle, angle), {\n                    owner: this$1,\n                    category: defined(fields.category) ? fields.category : \"\",\n                    index: i,\n                    series: currentSeries,\n                    seriesIx: seriesIx,\n                    dataItem: data[i],\n                    percentage: total !== 0 ? value / total : 0,\n                    explode: explode,\n                    visibleInLegend: fields.visibleInLegend,\n                    visible: visible,\n                    zIndex: seriesCount - seriesIx,\n                    animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)\n                });\n\n                if (visible !== false) {\n                    currentAngle += angle;\n                }\n            }\n        }\n    };\n\n    PieChart.prototype.evalSegmentOptions = function evalSegmentOptions (options, value, fields) {\n        var series = fields.series;\n\n        evalOptions(options, {\n            value: value,\n            series: series,\n            dataItem: fields.dataItem,\n            category: fields.category,\n            percentage: fields.percentage\n        }, { defaults: series._defaults, excluded: [ \"data\", \"content\", \"template\", \"visual\", \"toggle\" ] });\n    };\n\n    PieChart.prototype.addValue = function addValue (value, sector, fields) {\n        var segmentOptions = deepExtend({}, fields.series, { index: fields.index });\n        this.evalSegmentOptions(segmentOptions, value, fields);\n\n        this.createLegendItem(value, segmentOptions, fields);\n\n        if (fields.visible === false) {\n            return;\n        }\n\n        var segment = new PieSegment(value, sector, segmentOptions);\n        Object.assign(segment, fields);\n        this.append(segment);\n        this.points.push(segment);\n    };\n\n    PieChart.prototype.reflow = function reflow (targetBox) {\n        var ref = this;\n        var options = ref.options;\n        var points = ref.points;\n        var seriesConfigs = ref.seriesConfigs; if ( seriesConfigs === void 0 ) seriesConfigs = [];\n        var count = points.length;\n        var box = targetBox.clone();\n        var space = 5;\n        var minWidth = Math.min(box.width(), box.height());\n        var halfMinWidth = minWidth / 2;\n        var defaultPadding = minWidth - minWidth * 0.85;\n        var newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n        var newBoxCenter = newBox.center();\n        var boxCenter = box.center();\n        var seriesCount = options.series.length;\n        var leftSideLabels = [];\n        var rightSideLabels = [];\n        var padding = valueOrDefault(options.padding, defaultPadding);\n\n        this.targetBox = targetBox;\n\n        padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n        newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n\n        var radius = halfMinWidth - padding;\n        var center = new Point(\n            radius + newBox.x1 + padding,\n            radius + newBox.y1 + padding\n        );\n\n        for (var i = 0; i < count; i++) {\n            var segment = points[i];\n            var sector = segment.sector;\n            var seriesIndex = segment.seriesIx;\n            sector.radius = radius;\n            sector.center = center;\n\n            if (seriesConfigs.length) {\n                var seriesConfig = seriesConfigs[seriesIndex];\n                sector.innerRadius = seriesConfig.innerRadius;\n                sector.radius = seriesConfig.radius;\n            }\n\n            if (seriesIndex === seriesCount - 1 && segment.explode) {\n                sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n            }\n\n            segment.reflow(newBox);\n\n            var label = segment.label;\n            if (label) {\n                if (label.options.position === OUTSIDE_END) {\n                    if (seriesIndex === seriesCount - 1) {\n                        if (label.orientation === RIGHT) {\n                            rightSideLabels.push(label);\n                        } else {\n                            leftSideLabels.push(label);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (leftSideLabels.length > 0) {\n            leftSideLabels.sort(this.labelComparator(true));\n            this.leftLabelsReflow(leftSideLabels);\n        }\n\n        if (rightSideLabels.length > 0) {\n            rightSideLabels.sort(this.labelComparator(false));\n            this.rightLabelsReflow(rightSideLabels);\n        }\n\n        this.box = newBox;\n    };\n\n    PieChart.prototype.leftLabelsReflow = function leftLabelsReflow (labels) {\n        var distances = this.distanceBetweenLabels(labels);\n\n        this.distributeLabels(distances, labels);\n    };\n\n    PieChart.prototype.rightLabelsReflow = function rightLabelsReflow (labels) {\n        var distances = this.distanceBetweenLabels(labels);\n\n        this.distributeLabels(distances, labels);\n    };\n\n    PieChart.prototype.distanceBetweenLabels = function distanceBetweenLabels (labels) {\n        var segment = last(this.points);\n        var sector = segment.sector;\n        var count = labels.length - 1;\n        var lr = sector.radius + segment.options.labels.distance;\n        var distances = [];\n        var firstBox = labels[0].box;\n        var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n\n        distances.push(distance);\n\n        for (var i = 0; i < count; i++) {\n            var secondBox = labels[i + 1].box;\n\n            firstBox = labels[i].box;\n            distance = round(secondBox.y1 - firstBox.y2);\n            distances.push(distance);\n        }\n        distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n        distances.push(distance);\n\n        return distances;\n    };\n\n    PieChart.prototype.distributeLabels = function distributeLabels (distances, labels) {\n        var this$1 = this;\n\n        var count = distances.length;\n        var left, right, remaining;\n\n        for (var i = 0; i < count; i++) {\n            remaining = -distances[i];\n            left = right = i;\n\n            while (remaining > 0 && (left >= 0 || right < count)) {\n                remaining = this$1._takeDistance(distances, i, --left, remaining);\n                remaining = this$1._takeDistance(distances, i, ++right, remaining);\n            }\n        }\n\n        this.reflowLabels(distances, labels);\n    };\n\n    PieChart.prototype._takeDistance = function _takeDistance (distances, anchor, position, amount) {\n        var result = amount;\n        if (distances[position] > 0) {\n            var available = Math.min(distances[position], result);\n            result -= available;\n            distances[position] -= available;\n            distances[anchor] += available;\n        }\n\n        return result;\n    };\n\n    PieChart.prototype.reflowLabels = function reflowLabels (distances, labels) {\n        var this$1 = this;\n\n        var segment = last(this.points);\n        var sector = segment.sector;\n        var labelOptions = segment.options.labels;\n        var labelsCount = labels.length;\n        var labelDistance = labelOptions.distance;\n        var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n        var boxX;\n\n        distances[0] += 2;\n        for (var i = 0; i < labelsCount; i++) {\n            var label = labels[i];\n            var box = label.box;\n\n            boxY += distances[i];\n            boxX = this$1.hAlignLabel(\n                box.x2,\n                sector.clone().expand(labelDistance),\n                boxY,\n                boxY + box.height(),\n                label.orientation === RIGHT);\n\n            if (label.orientation === RIGHT) {\n                if (labelOptions.align !== CIRCLE) {\n                    boxX = sector.radius + sector.center.x + labelDistance;\n                }\n                label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n            } else {\n                if (labelOptions.align !== CIRCLE) {\n                    boxX = sector.center.x - sector.radius - labelDistance;\n                }\n                label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n            }\n\n            boxY += box.height();\n        }\n    };\n\n    PieChart.prototype.createVisual = function createVisual () {\n        var this$1 = this;\n\n        var ref = this;\n        var connectors = ref.options.connectors;\n        var points = ref.points;\n        var count = points.length;\n        var space = 4;\n\n        ChartElement.prototype.createVisual.call(this);\n\n        this._connectorLines = [];\n\n        for (var i = 0; i < count; i++) {\n            var segment = points[i];\n            var sector = segment.sector;\n            var label = segment.label;\n            var angle = sector.middle();\n            var connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n\n            if (label) {\n                var connectorLine = new draw.Path({\n                    stroke: {\n                        color: connectorsColor,\n                        width: connectors.width\n                    },\n                    animation: {\n                        type: FADEIN,\n                        delay: segment.animationDelay\n                    }\n                });\n\n                if (label.options.position === OUTSIDE_END) {\n                    var box = label.box;\n                    var centerPoint = sector.center;\n                    var start = sector.point(angle);\n                    var middle = new Point(box.x1, box.center().y);\n                    var sr = (void 0), end = (void 0), crossing = (void 0);\n\n                    start = sector.clone().expand(connectors.padding).point(angle);\n                    connectorLine.moveTo(start.x, start.y);\n                    // TODO: Extract into a method to remove duplication\n                    if (label.orientation === RIGHT) {\n                        end = new Point(box.x1 - connectors.padding, box.center().y);\n                        crossing = intersection(centerPoint, start, middle, end);\n                        middle = new Point(end.x - space, end.y);\n                        crossing = crossing || middle;\n                        crossing.x = Math.min(crossing.x, middle.x);\n\n                        if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) ||\n                            crossing.x < sector.center.x) {\n                            sr = sector.center.x + sector.radius + space;\n                            if (segment.options.labels.align !== COLUMN) {\n                                if (sr < middle.x) {\n                                    connectorLine.lineTo(sr, start.y);\n                                } else {\n                                    connectorLine.lineTo(start.x + space * 2, start.y);\n                                }\n                            } else {\n                                connectorLine.lineTo(sr, start.y);\n                            }\n                            connectorLine.lineTo(middle.x, end.y);\n                        } else {\n                            crossing.y = end.y;\n                            connectorLine.lineTo(crossing.x, crossing.y);\n                        }\n                    } else {\n                        end = new Point(box.x2 + connectors.padding, box.center().y);\n                        crossing = intersection(centerPoint, start, middle, end);\n                        middle = new Point(end.x + space, end.y);\n                        crossing = crossing || middle;\n                        crossing.x = Math.max(crossing.x, middle.x);\n\n                        if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) ||\n                            crossing.x > sector.center.x) {\n                            sr = sector.center.x - sector.radius - space;\n                            if (segment.options.labels.align !== COLUMN) {\n                                if (sr > middle.x) {\n                                    connectorLine.lineTo(sr, start.y);\n                                } else {\n                                    connectorLine.lineTo(start.x - space * 2, start.y);\n                                }\n                            } else {\n                                connectorLine.lineTo(sr, start.y);\n                            }\n                            connectorLine.lineTo(middle.x, end.y);\n                        } else {\n                            crossing.y = end.y;\n                            connectorLine.lineTo(crossing.x, crossing.y);\n                        }\n                    }\n\n                    connectorLine.lineTo(end.x, end.y);\n\n                    this$1._connectorLines.push(connectorLine);\n                    this$1.visual.append(connectorLine);\n                }\n            }\n        }\n    };\n\n    PieChart.prototype.renderVisual = function renderVisual () {\n        ChartElement.prototype.renderVisual.call(this);\n\n        if (find(this.options.series, function (options) { return options.autoFit; })) {\n            var targetBox = this.targetBox;\n            var pieCenter = this.box.center();\n            var bbox = this.visual.bbox();\n            if (!bbox) {\n                return;\n            }\n\n            var bboxBottom = bbox.bottomRight();\n\n            var scale = Math.min(\n                (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),\n                (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),\n                (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),\n                (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)\n            );\n\n            if (scale < 1) {\n                this.visual.transform(geometry.transform().scale(scale, scale, [ pieCenter.x, pieCenter.y ]));\n            }\n        }\n    };\n\n    PieChart.prototype.labelComparator = function labelComparator (reverse) {\n        var reverseValue = reverse ? -1 : 1;\n\n        return function(a, b) {\n            var first = (a.parent.sector.middle() + 270) % 360;\n            var second = (b.parent.sector.middle() + 270) % 360;\n            return (first - second) * reverseValue;\n        };\n    };\n\n    PieChart.prototype.hAlignLabel = function hAlignLabel (originalX, sector, y1, y2, direction) {\n        var radius = sector.radius;\n        var sector_center = sector.center;\n        var cx = sector_center.x;\n        var cy = sector_center.y;\n        var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n\n        if (t > radius) {\n            return originalX;\n        }\n\n        return cx + Math.sqrt((radius * radius) - (t * t)) * (direction ? 1 : -1);\n    };\n\n    PieChart.prototype.pointInCircle = function pointInCircle (point, center, radius) {\n        return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n    };\n\n    PieChart.prototype.formatPointValue = function formatPointValue (point, format) {\n        return this.chartService.format.auto(format, point.value);\n    };\n\n    PieChart.prototype.animationDelay = function animationDelay (categoryIndex) {\n        return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n    };\n\n    PieChart.prototype.stackRoot = function stackRoot () {\n        return this;\n    };\n\n    return PieChart;\n}(ChartElement));\n\nfunction intersection(a1, a2, b1, b2) {\n    var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n    var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n\n    var result;\n    if (ub !== 0) {\n        var ua = (uat / ub);\n\n        result = new Point(\n            a1.x + ua * (a2.x - a1.x),\n            a1.y + ua * (a2.y - a1.y)\n        );\n    }\n\n    return result;\n}\n\nsetDefaultOptions(PieChart, {\n    startAngle: 90,\n    connectors: {\n        width: 2,\n        color: \"#939393\",\n        padding: 8\n    },\n    inactiveItems: {\n        markers: {},\n        labels: {}\n    }\n});\n\ndeepExtend(PieChart.prototype, PieChartMixin);\n\nPieChart.prototype.isStackRoot = true;\n\nexport default PieChart;\n"]},"metadata":{},"sourceType":"module"}