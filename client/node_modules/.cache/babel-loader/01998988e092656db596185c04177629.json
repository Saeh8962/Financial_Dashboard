{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport limitCoordinate from './utils/limit-coordinate';\nimport { DEFAULT_PRECISION, BLACK, X, Y } from '../common/constants';\nimport { deepExtend, defined, inArray, limitValue, round, setDefaultOptions } from '../common';\nvar DEFAULT_MAJOR_UNIT = 10;\n\nvar LogarithmicAxis = function (Axis) {\n  function LogarithmicAxis(seriesMin, seriesMax, options, chartService) {\n    var axisOptions = deepExtend({\n      majorUnit: DEFAULT_MAJOR_UNIT,\n      min: seriesMin,\n      max: seriesMax\n    }, options);\n    var base = axisOptions.majorUnit;\n    var autoMax = autoAxisMax(seriesMax, base);\n    var autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions);\n    var range = initRange(autoMin, autoMax, axisOptions, options);\n    axisOptions.max = range.max;\n    axisOptions.min = range.min;\n    axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n    Axis.call(this, axisOptions, chartService);\n    this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n    this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n    this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n    this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n    this.seriesMin = seriesMin;\n    this.seriesMax = seriesMax;\n    this.createLabels();\n  }\n\n  if (Axis) LogarithmicAxis.__proto__ = Axis;\n  LogarithmicAxis.prototype = Object.create(Axis && Axis.prototype);\n  LogarithmicAxis.prototype.constructor = LogarithmicAxis;\n\n  LogarithmicAxis.prototype.clone = function clone() {\n    return new LogarithmicAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);\n  };\n\n  LogarithmicAxis.prototype.startValue = function startValue() {\n    return this.options.min;\n  };\n\n  LogarithmicAxis.prototype.getSlot = function getSlot(a, b, limit) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var reverse = options.reverse;\n    var vertical = options.vertical;\n    var base = options.majorUnit;\n    var valueAxis = vertical ? Y : X;\n    var lineBox = this.lineBox();\n    var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var dir = reverse ? -1 : 1;\n    var step = dir * (lineSize / (logMax - logMin));\n    var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n    var start = a;\n    var end = b;\n\n    if (!defined(start)) {\n      start = end || 1;\n    }\n\n    if (!defined(end)) {\n      end = start || 1;\n    }\n\n    if (start <= 0 || end <= 0) {\n      return null;\n    }\n\n    if (limit) {\n      start = Math.max(Math.min(start, options.max), options.min);\n      end = Math.max(Math.min(end, options.max), options.min);\n    }\n\n    start = log(start, base);\n    end = log(end, base);\n    var p1, p2;\n\n    if (vertical) {\n      p1 = logMax - Math.max(start, end);\n      p2 = logMax - Math.min(start, end);\n    } else {\n      p1 = Math.min(start, end) - logMin;\n      p2 = Math.max(start, end) - logMin;\n    }\n\n    slotBox[valueAxis + 1] = limitCoordinate(lineStart + step * (reverse ? p2 : p1));\n    slotBox[valueAxis + 2] = limitCoordinate(lineStart + step * (reverse ? p1 : p2));\n    return slotBox;\n  };\n\n  LogarithmicAxis.prototype.getValue = function getValue(point) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var reverse = options.reverse;\n    var vertical = options.vertical;\n    var base = options.majorUnit;\n    var lineBox = this.lineBox();\n    var dir = vertical === reverse ? 1 : -1;\n    var startEdge = dir === 1 ? 1 : 2;\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var step = (logMax - logMin) / lineSize;\n    var valueAxis = vertical ? Y : X;\n    var lineStart = lineBox[valueAxis + startEdge];\n    var offset = dir * (point[valueAxis] - lineStart);\n    var valueOffset = offset * step;\n\n    if (offset < 0 || offset > lineSize) {\n      return null;\n    }\n\n    var value = logMin + valueOffset;\n    return round(Math.pow(base, value), DEFAULT_PRECISION);\n  };\n\n  LogarithmicAxis.prototype.range = function range() {\n    var options = this.options;\n    return {\n      min: options.min,\n      max: options.max\n    };\n  };\n\n  LogarithmicAxis.prototype.scaleRange = function scaleRange(delta) {\n    var base = this.options.majorUnit;\n    var offset = -delta;\n    return {\n      min: Math.pow(base, this.logMin - offset),\n      max: Math.pow(base, this.logMax + offset)\n    };\n  };\n\n  LogarithmicAxis.prototype.translateRange = function translateRange(delta) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var reverse = options.reverse;\n    var vertical = options.vertical;\n    var base = options.majorUnit;\n    var lineBox = this.lineBox();\n    var size = vertical ? lineBox.height() : lineBox.width();\n    var scale = size / (logMax - logMin);\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n\n    if ((vertical || reverse) && !(vertical && reverse)) {\n      offset = -offset;\n    }\n\n    return {\n      min: Math.pow(base, logMin + offset),\n      max: Math.pow(base, logMax + offset),\n      offset: offset\n    };\n  };\n\n  LogarithmicAxis.prototype.labelsCount = function labelsCount() {\n    var floorMax = Math.floor(this.logMax);\n    var count = Math.floor(floorMax - this.logMin) + 1;\n    return count;\n  };\n\n  LogarithmicAxis.prototype.getMajorTickPositions = function getMajorTickPositions() {\n    var ticks = [];\n    this.traverseMajorTicksPositions(function (position) {\n      ticks.push(position);\n    }, {\n      step: 1,\n      skip: 0\n    });\n    return ticks;\n  };\n\n  LogarithmicAxis.prototype.createTicks = function createTicks(lineGroup) {\n    var options = this.options;\n    var majorTicks = options.majorTicks;\n    var minorTicks = options.minorTicks;\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var lineBox = this.lineBox();\n    var ticks = [];\n    var tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: vertical\n    };\n\n    function render(tickPosition, tickOptions) {\n      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n      tickLineOptions.position = tickPosition;\n      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n    }\n\n    if (majorTicks.visible) {\n      this.traverseMajorTicksPositions(render, majorTicks);\n    }\n\n    if (minorTicks.visible) {\n      this.traverseMinorTicksPositions(render, minorTicks);\n    }\n\n    return ticks;\n  };\n\n  LogarithmicAxis.prototype.createGridLines = function createGridLines(altAxis) {\n    var options = this.options;\n    var minorGridLines = options.minorGridLines;\n    var majorGridLines = options.majorGridLines;\n    var vertical = options.vertical;\n    var lineBox = altAxis.lineBox();\n    var lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    var majorTicks = [];\n    var container = this.gridLinesVisual();\n\n    function render(tickPosition, gridLine) {\n      if (!inArray(tickPosition, majorTicks)) {\n        lineOptions.position = tickPosition;\n        container.append(createAxisGridLine(lineOptions, gridLine));\n        majorTicks.push(tickPosition);\n      }\n    }\n\n    if (majorGridLines.visible) {\n      this.traverseMajorTicksPositions(render, majorGridLines);\n    }\n\n    if (minorGridLines.visible) {\n      this.traverseMinorTicksPositions(render, minorGridLines);\n    }\n\n    return container.children;\n  };\n\n  LogarithmicAxis.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions(callback, tickOptions) {\n    var ref = this._lineOptions();\n\n    var lineStart = ref.lineStart;\n    var step = ref.step;\n    var ref$1 = this;\n    var logMin = ref$1.logMin;\n    var logMax = ref$1.logMax;\n\n    for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n      var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n      callback(position, tickOptions);\n    }\n  };\n\n  LogarithmicAxis.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions(callback, tickOptions) {\n    var this$1 = this;\n    var ref = this.options;\n    var min = ref.min;\n    var max = ref.max;\n    var minorUnit = ref.minorUnit;\n    var base = ref.majorUnit;\n\n    var ref$1 = this._lineOptions();\n\n    var lineStart = ref$1.lineStart;\n    var step = ref$1.step;\n    var ref$2 = this;\n    var logMin = ref$2.logMin;\n    var logMax = ref$2.logMax;\n    var start = Math.floor(logMin);\n\n    for (var power = start; power < logMax; power++) {\n      var minorOptions = this$1._minorIntervalOptions(power);\n\n      for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n        var value = minorOptions.value + idx * minorOptions.minorStep;\n\n        if (value > max) {\n          break;\n        }\n\n        if (value >= min) {\n          var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n          callback(position, tickOptions);\n        }\n      }\n    }\n  };\n\n  LogarithmicAxis.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {\n    var power = Math.ceil(this.logMin + index);\n    var value = Math.pow(this.options.majorUnit, power);\n    var text = this.axisLabelText(value, labelOptions, labelContext);\n    return new AxisLabel(value, text, index, null, labelOptions);\n  };\n\n  LogarithmicAxis.prototype.shouldRenderNote = function shouldRenderNote(value) {\n    var range = this.range();\n    return range.min <= value && value <= range.max;\n  };\n\n  LogarithmicAxis.prototype.pan = function pan(delta) {\n    var range = this.translateRange(delta);\n    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n  };\n\n  LogarithmicAxis.prototype.pointsRange = function pointsRange(start, end) {\n    var startValue = this.getValue(start);\n    var endValue = this.getValue(end);\n    var min = Math.min(startValue, endValue);\n    var max = Math.max(startValue, endValue);\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  LogarithmicAxis.prototype.zoomRange = function zoomRange(delta) {\n    var ref = this;\n    var options = ref.options;\n    var totalMin = ref.totalMin;\n    var totalMax = ref.totalMax;\n    var newRange = this.scaleRange(delta);\n    var min = limitValue(newRange.min, totalMin, totalMax);\n    var max = limitValue(newRange.max, totalMin, totalMax);\n    var base = options.majorUnit;\n    var acceptOptionsRange = max > min && options.min && options.max && round(log(options.max, base) - log(options.min, base), DEFAULT_PRECISION) < 1;\n    var acceptNewRange = !(options.min === totalMin && options.max === totalMax) && round(log(max, base) - log(min, base), DEFAULT_PRECISION) >= 1;\n\n    if (acceptOptionsRange || acceptNewRange) {\n      return {\n        min: min,\n        max: max\n      };\n    }\n  };\n\n  LogarithmicAxis.prototype._minorIntervalOptions = function _minorIntervalOptions(power) {\n    var ref = this.options;\n    var minorUnit = ref.minorUnit;\n    var base = ref.majorUnit;\n    var value = Math.pow(base, power);\n    var nextValue = Math.pow(base, power + 1);\n    var difference = nextValue - value;\n    var minorStep = difference / minorUnit;\n    return {\n      value: value,\n      minorStep: minorStep\n    };\n  };\n\n  LogarithmicAxis.prototype._lineOptions = function _lineOptions() {\n    var ref = this.options;\n    var reverse = ref.reverse;\n    var vertical = ref.vertical;\n    var valueAxis = vertical ? Y : X;\n    var lineBox = this.lineBox();\n    var dir = vertical === reverse ? 1 : -1;\n    var startEdge = dir === 1 ? 1 : 2;\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var step = dir * (lineSize / (this.logMax - this.logMin));\n    var lineStart = lineBox[valueAxis + startEdge];\n    return {\n      step: step,\n      lineStart: lineStart,\n      lineBox: lineBox\n    };\n  };\n\n  return LogarithmicAxis;\n}(Axis);\n\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n  var min = axisOptions.min;\n  var max = axisOptions.max;\n\n  if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n    throwNegativeValuesError();\n  }\n\n  if (!defined(options.max)) {\n    max = autoMax;\n  } else if (options.max <= 0) {\n    throwNegativeValuesError();\n  }\n\n  if (!defined(options.min)) {\n    min = autoMin;\n  } else if (options.min <= 0) {\n    throwNegativeValuesError();\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction autoAxisMin(min, max, options) {\n  var base = options.majorUnit;\n  var autoMin = min;\n\n  if (min <= 0) {\n    autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n  } else if (!options.narrowRange) {\n    autoMin = Math.pow(base, Math.floor(log(min, base)));\n  }\n\n  return autoMin;\n}\n\nfunction autoAxisMax(max, base) {\n  var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n  var autoMax;\n\n  if (max <= 0) {\n    autoMax = base;\n  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n    autoMax = Math.pow(base, log(max, base) + 0.2);\n  } else {\n    autoMax = Math.pow(base, Math.ceil(log(max, base)));\n  }\n\n  return autoMax;\n}\n\nfunction throwNegativeValuesError() {\n  throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\n\nfunction log(y, x) {\n  return Math.log(y) / Math.log(x);\n}\n\nsetDefaultOptions(LogarithmicAxis, {\n  type: \"log\",\n  majorUnit: DEFAULT_MAJOR_UNIT,\n  minorUnit: 1,\n  axisCrossingValue: 1,\n  vertical: true,\n  majorGridLines: {\n    visible: true,\n    width: 1,\n    color: BLACK\n  },\n  zIndex: 1,\n  _deferLabels: true\n});\nexport default LogarithmicAxis;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/node_modules/@progress/kendo-charts/dist/es/core/logarithmic-axis.js"],"names":["Axis","AxisLabel","Box","createAxisTick","createAxisGridLine","limitCoordinate","DEFAULT_PRECISION","BLACK","X","Y","deepExtend","defined","inArray","limitValue","round","setDefaultOptions","DEFAULT_MAJOR_UNIT","LogarithmicAxis","seriesMin","seriesMax","options","chartService","axisOptions","majorUnit","min","max","base","autoMax","autoAxisMax","autoMin","autoAxisMin","range","initRange","minorUnit","call","totalMin","Math","totalMax","logMin","log","logMax","createLabels","__proto__","prototype","Object","create","constructor","clone","assign","startValue","getSlot","a","b","limit","ref","reverse","vertical","valueAxis","lineBox","lineStart","lineSize","height","width","dir","step","slotBox","x1","y1","start","end","p1","p2","getValue","point","startEdge","offset","valueOffset","value","pow","scaleRange","delta","translateRange","size","scale","labelsCount","floorMax","floor","count","getMajorTickPositions","ticks","traverseMajorTicksPositions","position","push","skip","createTicks","lineGroup","majorTicks","minorTicks","mirror","labels","tickLineOptions","render","tickPosition","tickOptions","tickX","x2","tickY","append","visible","traverseMinorTicksPositions","createGridLines","altAxis","minorGridLines","majorGridLines","lineOptions","lineEnd","container","gridLinesVisual","gridLine","children","callback","_lineOptions","ref$1","power","ceil","this$1","ref$2","minorOptions","_minorIntervalOptions","idx","minorStep","createAxisLabel","index","labelOptions","labelContext","text","axisLabelText","shouldRenderNote","pan","limitRange","pointsRange","endValue","zoomRange","newRange","acceptOptionsRange","acceptNewRange","nextValue","difference","axisCrossingValue","throwNegativeValuesError","narrowRange","logMaxRemainder","Error","y","x","type","color","zIndex","_deferLabels"],"mappings":"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","sourcesContent":["\nimport Axis from './axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\n\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport limitCoordinate from './utils/limit-coordinate';\n\nimport { DEFAULT_PRECISION, BLACK, X, Y } from '../common/constants';\nimport { deepExtend, defined, inArray, limitValue, round, setDefaultOptions } from '../common';\n\nvar DEFAULT_MAJOR_UNIT = 10;\n\nvar LogarithmicAxis = (function (Axis) {\n    function LogarithmicAxis(seriesMin, seriesMax, options, chartService) {\n\n        var axisOptions = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);\n        var base = axisOptions.majorUnit;\n        var autoMax = autoAxisMax(seriesMax, base);\n        var autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions);\n        var range = initRange(autoMin, autoMax, axisOptions, options);\n\n        axisOptions.max = range.max;\n        axisOptions.min = range.min;\n        axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n\n        Axis.call(this, axisOptions, chartService);\n\n        this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n        this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n        this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n        this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n        this.seriesMin = seriesMin;\n        this.seriesMax = seriesMax;\n\n        this.createLabels();\n    }\n\n    if ( Axis ) LogarithmicAxis.__proto__ = Axis;\n    LogarithmicAxis.prototype = Object.create( Axis && Axis.prototype );\n    LogarithmicAxis.prototype.constructor = LogarithmicAxis;\n\n    LogarithmicAxis.prototype.clone = function clone () {\n        return new LogarithmicAxis(\n            this.seriesMin,\n            this.seriesMax,\n            Object.assign({}, this.options),\n            this.chartService\n        );\n    };\n\n    LogarithmicAxis.prototype.startValue = function startValue () {\n        return this.options.min;\n    };\n\n    LogarithmicAxis.prototype.getSlot = function getSlot (a, b, limit) {\n        var ref = this;\n        var options = ref.options;\n        var logMin = ref.logMin;\n        var logMax = ref.logMax;\n        var reverse = options.reverse;\n        var vertical = options.vertical;\n        var base = options.majorUnit;\n        var valueAxis = vertical ? Y : X;\n        var lineBox = this.lineBox();\n        var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n        var lineSize = vertical ? lineBox.height() : lineBox.width();\n        var dir = reverse ? -1 : 1;\n        var step = dir * (lineSize / (logMax - logMin));\n        var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n        var start = a;\n        var end = b;\n\n        if (!defined(start)) {\n            start = end || 1;\n        }\n\n        if (!defined(end)) {\n            end = start || 1;\n        }\n\n        if (start <= 0 || end <= 0) {\n            return null;\n        }\n\n        if (limit) {\n            start = Math.max(Math.min(start, options.max), options.min);\n            end = Math.max(Math.min(end, options.max), options.min);\n        }\n\n        start = log(start, base);\n        end = log(end, base);\n\n        var p1, p2;\n\n        if (vertical) {\n            p1 = logMax - Math.max(start, end);\n            p2 = logMax - Math.min(start, end);\n        } else {\n            p1 = Math.min(start, end) - logMin;\n            p2 = Math.max(start, end) - logMin;\n        }\n\n        slotBox[valueAxis + 1] = limitCoordinate(lineStart + step * (reverse ? p2 : p1));\n        slotBox[valueAxis + 2] = limitCoordinate(lineStart + step * (reverse ? p1 : p2));\n\n        return slotBox;\n    };\n\n    LogarithmicAxis.prototype.getValue = function getValue (point) {\n        var ref = this;\n        var options = ref.options;\n        var logMin = ref.logMin;\n        var logMax = ref.logMax;\n        var reverse = options.reverse;\n        var vertical = options.vertical;\n        var base = options.majorUnit;\n        var lineBox = this.lineBox();\n        var dir = vertical === reverse ? 1 : -1;\n        var startEdge = dir === 1 ? 1 : 2;\n        var lineSize = vertical ? lineBox.height() : lineBox.width();\n        var step = ((logMax - logMin) / lineSize);\n        var valueAxis = vertical ? Y : X;\n        var lineStart = lineBox[valueAxis + startEdge];\n        var offset = dir * (point[valueAxis] - lineStart);\n        var valueOffset = offset * step;\n\n        if (offset < 0 || offset > lineSize) {\n            return null;\n        }\n\n        var value = logMin + valueOffset;\n\n        return round(Math.pow(base, value), DEFAULT_PRECISION);\n    };\n\n    LogarithmicAxis.prototype.range = function range () {\n        var options = this.options;\n        return { min: options.min, max: options.max };\n    };\n\n    LogarithmicAxis.prototype.scaleRange = function scaleRange (delta) {\n        var base = this.options.majorUnit;\n        var offset = -delta;\n\n        return {\n            min: Math.pow(base, this.logMin - offset),\n            max: Math.pow(base, this.logMax + offset)\n        };\n    };\n\n    LogarithmicAxis.prototype.translateRange = function translateRange (delta) {\n        var ref = this;\n        var options = ref.options;\n        var logMin = ref.logMin;\n        var logMax = ref.logMax;\n        var reverse = options.reverse;\n        var vertical = options.vertical;\n        var base = options.majorUnit;\n        var lineBox = this.lineBox();\n        var size = vertical ? lineBox.height() : lineBox.width();\n        var scale = size / (logMax - logMin);\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n        if ((vertical || reverse) && !(vertical && reverse )) {\n            offset = -offset;\n        }\n\n        return {\n            min: Math.pow(base, logMin + offset),\n            max: Math.pow(base, logMax + offset),\n            offset: offset\n        };\n    };\n\n    LogarithmicAxis.prototype.labelsCount = function labelsCount () {\n        var floorMax = Math.floor(this.logMax);\n        var count = Math.floor(floorMax - this.logMin) + 1;\n\n        return count;\n    };\n\n    LogarithmicAxis.prototype.getMajorTickPositions = function getMajorTickPositions () {\n        var ticks = [];\n\n        this.traverseMajorTicksPositions(function (position) {\n            ticks.push(position);\n        }, { step: 1, skip: 0 });\n\n        return ticks;\n    };\n\n    LogarithmicAxis.prototype.createTicks = function createTicks (lineGroup) {\n        var options = this.options;\n        var majorTicks = options.majorTicks;\n        var minorTicks = options.minorTicks;\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var lineBox = this.lineBox();\n        var ticks = [];\n        var tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: vertical\n        };\n\n        function render(tickPosition, tickOptions) {\n            tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n            tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n            tickLineOptions.position = tickPosition;\n\n            lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n\n        if (majorTicks.visible) {\n            this.traverseMajorTicksPositions(render, majorTicks);\n        }\n\n        if (minorTicks.visible) {\n            this.traverseMinorTicksPositions(render, minorTicks);\n        }\n\n        return ticks;\n    };\n\n    LogarithmicAxis.prototype.createGridLines = function createGridLines (altAxis) {\n        var options = this.options;\n        var minorGridLines = options.minorGridLines;\n        var majorGridLines = options.majorGridLines;\n        var vertical = options.vertical;\n        var lineBox = altAxis.lineBox();\n        var lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        var majorTicks = [];\n\n        var container = this.gridLinesVisual();\n        function render(tickPosition, gridLine) {\n            if (!inArray(tickPosition, majorTicks)) {\n                lineOptions.position = tickPosition;\n                container.append(createAxisGridLine(lineOptions, gridLine));\n\n                majorTicks.push(tickPosition);\n            }\n        }\n\n        if (majorGridLines.visible) {\n            this.traverseMajorTicksPositions(render, majorGridLines);\n        }\n\n        if (minorGridLines.visible) {\n            this.traverseMinorTicksPositions(render, minorGridLines);\n        }\n\n        return container.children;\n    };\n\n    LogarithmicAxis.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions (callback, tickOptions) {\n        var ref = this._lineOptions();\n        var lineStart = ref.lineStart;\n        var step = ref.step;\n        var ref$1 = this;\n        var logMin = ref$1.logMin;\n        var logMax = ref$1.logMax;\n\n        for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n            var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n            callback(position, tickOptions);\n        }\n    };\n\n    LogarithmicAxis.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions (callback, tickOptions) {\n        var this$1 = this;\n\n        var ref = this.options;\n        var min = ref.min;\n        var max = ref.max;\n        var minorUnit = ref.minorUnit;\n        var base = ref.majorUnit;\n        var ref$1 = this._lineOptions();\n        var lineStart = ref$1.lineStart;\n        var step = ref$1.step;\n        var ref$2 = this;\n        var logMin = ref$2.logMin;\n        var logMax = ref$2.logMax;\n        var start = Math.floor(logMin);\n\n        for (var power = start; power < logMax; power++) {\n            var minorOptions = this$1._minorIntervalOptions(power);\n            for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n                var value = minorOptions.value + idx * minorOptions.minorStep;\n                if (value > max) {\n                    break;\n                }\n                if (value >= min) {\n                    var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n                    callback(position, tickOptions);\n                }\n            }\n        }\n    };\n\n    LogarithmicAxis.prototype.createAxisLabel = function createAxisLabel (index, labelOptions, labelContext) {\n        var power = Math.ceil(this.logMin + index);\n        var value = Math.pow(this.options.majorUnit, power);\n        var text = this.axisLabelText(value, labelOptions, labelContext);\n\n        return new AxisLabel(value, text, index, null, labelOptions);\n    };\n\n    LogarithmicAxis.prototype.shouldRenderNote = function shouldRenderNote (value) {\n        var range = this.range();\n        return range.min <= value && value <= range.max;\n    };\n\n    LogarithmicAxis.prototype.pan = function pan (delta) {\n        var range = this.translateRange(delta);\n        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n    };\n\n    LogarithmicAxis.prototype.pointsRange = function pointsRange (start, end) {\n        var startValue = this.getValue(start);\n        var endValue = this.getValue(end);\n        var min = Math.min(startValue, endValue);\n        var max = Math.max(startValue, endValue);\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    LogarithmicAxis.prototype.zoomRange = function zoomRange (delta) {\n        var ref = this;\n        var options = ref.options;\n        var totalMin = ref.totalMin;\n        var totalMax = ref.totalMax;\n        var newRange = this.scaleRange(delta);\n        var min = limitValue(newRange.min, totalMin, totalMax);\n        var max = limitValue(newRange.max, totalMin, totalMax);\n        var base = options.majorUnit;\n        var acceptOptionsRange = max > min && options.min && options.max && (round(log(options.max, base) - log(options.min, base), DEFAULT_PRECISION) < 1);\n        var acceptNewRange = !(options.min === totalMin && options.max === totalMax) && round(log(max, base) - log(min, base), DEFAULT_PRECISION) >= 1;\n\n        if (acceptOptionsRange || acceptNewRange) {\n            return {\n                min: min,\n                max: max\n            };\n        }\n    };\n\n    LogarithmicAxis.prototype._minorIntervalOptions = function _minorIntervalOptions (power) {\n        var ref = this.options;\n        var minorUnit = ref.minorUnit;\n        var base = ref.majorUnit;\n        var value = Math.pow(base, power);\n        var nextValue = Math.pow(base, power + 1);\n        var difference = nextValue - value;\n        var minorStep = difference / minorUnit;\n\n        return {\n            value: value,\n            minorStep: minorStep\n        };\n    };\n\n    LogarithmicAxis.prototype._lineOptions = function _lineOptions () {\n        var ref = this.options;\n        var reverse = ref.reverse;\n        var vertical = ref.vertical;\n        var valueAxis = vertical ? Y : X;\n        var lineBox = this.lineBox();\n        var dir = vertical === reverse ? 1 : -1;\n        var startEdge = dir === 1 ? 1 : 2;\n        var lineSize = vertical ? lineBox.height() : lineBox.width();\n        var step = dir * (lineSize / (this.logMax - this.logMin));\n        var lineStart = lineBox[valueAxis + startEdge];\n\n        return {\n            step: step,\n            lineStart: lineStart,\n            lineBox: lineBox\n        };\n    };\n\n    return LogarithmicAxis;\n}(Axis));\n\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n    var min = axisOptions.min;\n    var max = axisOptions.max;\n\n    if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n        throwNegativeValuesError();\n    }\n\n    if (!defined(options.max)) {\n        max = autoMax;\n    } else if (options.max <= 0) {\n        throwNegativeValuesError();\n    }\n\n    if (!defined(options.min)) {\n        min = autoMin;\n    } else if (options.min <= 0) {\n        throwNegativeValuesError();\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\nfunction autoAxisMin(min, max, options) {\n    var base = options.majorUnit;\n    var autoMin = min;\n    if (min <= 0) {\n        autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n    } else if (!options.narrowRange) {\n        autoMin = Math.pow(base, Math.floor(log(min, base)));\n    }\n    return autoMin;\n}\n\nfunction autoAxisMax(max, base) {\n    var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n    var autoMax;\n    if (max <= 0) {\n        autoMax = base;\n    } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n        autoMax = Math.pow(base, log(max, base) + 0.2);\n    } else {\n        autoMax = Math.pow(base, Math.ceil(log(max, base)));\n    }\n\n    return autoMax;\n}\n\nfunction throwNegativeValuesError() {\n    throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\n\nfunction log(y, x) {\n    return Math.log(y) / Math.log(x);\n}\n\nsetDefaultOptions(LogarithmicAxis, {\n    type: \"log\",\n    majorUnit: DEFAULT_MAJOR_UNIT,\n    minorUnit: 1,\n    axisCrossingValue: 1,\n    vertical: true,\n    majorGridLines: {\n        visible: true,\n        width: 1,\n        color: BLACK\n    },\n    zIndex: 1,\n    _deferLabels: true\n});\n\nexport default LogarithmicAxis;\n"]},"metadata":{},"sourceType":"module"}