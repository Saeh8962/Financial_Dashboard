{"ast":null,"code":"import { drawing as draw, Color } from '@progress/kendo-drawing';\nimport BarLabel from './bar-label';\nimport { BORDER_BRIGHTNESS, TOOLTIP_OFFSET } from '../constants';\nimport hasGradientOverlay from '../utils/has-gradient-overlay';\nimport { ChartElement, Point } from '../../core';\nimport PointEventsMixin from '../mixins/point-events-mixin';\nimport NoteMixin from '../mixins/note-mixin';\nimport { WHITE, LEFT, RIGHT, BOTTOM, TOP } from '../../common/constants';\nimport { alignPathToPixel, deepExtend, defined, getTemplate, valueOrDefault } from '../../common';\nvar BAR_ALIGN_MIN_WIDTH = 6;\n\nvar Bar = function (ChartElement) {\n  function Bar(value, options) {\n    ChartElement.call(this);\n    this.options = options;\n    this.color = options.color || WHITE;\n    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n    this.value = value;\n  }\n\n  if (ChartElement) Bar.__proto__ = ChartElement;\n  Bar.prototype = Object.create(ChartElement && ChartElement.prototype);\n  Bar.prototype.constructor = Bar;\n\n  Bar.prototype.render = function render() {\n    if (this._rendered) {\n      return;\n    }\n\n    this._rendered = true;\n    this.createLabel();\n    this.createNote();\n\n    if (this.errorBar) {\n      this.append(this.errorBar);\n    }\n  };\n\n  Bar.prototype.createLabel = function createLabel() {\n    var options = this.options;\n    var labels = options.labels;\n\n    if (labels.visible) {\n      var pointData = this.pointData();\n      var labelTemplate = getTemplate(labels);\n      var labelText;\n\n      if (labelTemplate) {\n        labelText = labelTemplate(pointData);\n      } else {\n        labelText = this.formatValue(labels.format);\n      }\n\n      this.label = new BarLabel(labelText, deepExtend({\n        vertical: options.vertical\n      }, labels), pointData);\n      this.append(this.label);\n    }\n  };\n\n  Bar.prototype.formatValue = function formatValue(format) {\n    return this.owner.formatPointValue(this, format);\n  };\n\n  Bar.prototype.reflow = function reflow(targetBox) {\n    var this$1 = this;\n    this.render();\n    var label = this.label;\n    this.box = targetBox;\n\n    if (label) {\n      label.options.aboveAxis = this.aboveAxis;\n      label.reflow(targetBox);\n    }\n\n    if (this.note) {\n      this.note.reflow(targetBox);\n    }\n\n    if (this.errorBars) {\n      for (var i = 0; i < this.errorBars.length; i++) {\n        this$1.errorBars[i].reflow(targetBox);\n      }\n    }\n  };\n\n  Bar.prototype.createVisual = function createVisual() {\n    var this$1 = this;\n    var ref = this;\n    var box = ref.box;\n    var options = ref.options;\n    var customVisual = options.visual;\n\n    if (this.visible !== false) {\n      ChartElement.prototype.createVisual.call(this);\n\n      if (customVisual) {\n        var visual = this.rectVisual = customVisual({\n          category: this.category,\n          dataItem: this.dataItem,\n          value: this.value,\n          sender: this.getSender(),\n          series: this.series,\n          percentage: this.percentage,\n          stackValue: this.stackValue,\n          runningTotal: this.runningTotal,\n          total: this.total,\n          rect: box.toRect(),\n          createVisual: function createVisual() {\n            var group = new draw.Group();\n            this$1.createRect(group);\n            return group;\n          },\n          options: options\n        });\n\n        if (visual) {\n          this.visual.append(visual);\n        }\n      } else if (box.width() > 0 && box.height() > 0) {\n        this.createRect(this.visual);\n      }\n    }\n  };\n\n  Bar.prototype.createRect = function createRect(visual) {\n    var options = this.options;\n    var border = options.border;\n    var strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;\n    var rect = this.box.toRect();\n    rect.size.width = Math.round(rect.size.width);\n    var path = this.rectVisual = draw.Path.fromRect(rect, {\n      fill: {\n        color: this.color,\n        opacity: options.opacity\n      },\n      stroke: {\n        color: this.getBorderColor(),\n        width: border.width,\n        opacity: strokeOpacity,\n        dashType: border.dashType\n      }\n    });\n    var width = this.box.width();\n    var height = this.box.height();\n    var size = options.vertical ? width : height;\n\n    if (size > BAR_ALIGN_MIN_WIDTH) {\n      alignPathToPixel(path); // Fixes lineJoin issue in firefox when the joined lines are parallel\n\n      if (width < 1 || height < 1) {\n        path.options.stroke.lineJoin = \"round\";\n      }\n    }\n\n    visual.append(path);\n\n    if (hasGradientOverlay(options)) {\n      var overlay = this.createGradientOverlay(path, {\n        baseColor: this.color\n      }, deepExtend({\n        end: !options.vertical ? [0, 1] : undefined\n      }, options.overlay));\n      visual.append(overlay);\n    }\n  };\n\n  Bar.prototype.createHighlight = function createHighlight(style) {\n    var highlight = draw.Path.fromRect(this.box.toRect(), style);\n    return alignPathToPixel(highlight);\n  };\n\n  Bar.prototype.highlightVisual = function highlightVisual() {\n    return this.rectVisual;\n  };\n\n  Bar.prototype.highlightVisualArgs = function highlightVisualArgs() {\n    return {\n      options: this.options,\n      rect: this.box.toRect(),\n      visual: this.rectVisual\n    };\n  };\n\n  Bar.prototype.getBorderColor = function getBorderColor() {\n    var color = this.color;\n    var border = this.options.border;\n    var brightness = border._brightness || BORDER_BRIGHTNESS;\n    var borderColor = border.color;\n\n    if (!defined(borderColor)) {\n      borderColor = new Color(color).brightness(brightness).toHex();\n    }\n\n    return borderColor;\n  };\n\n  Bar.prototype.tooltipAnchor = function tooltipAnchor() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var aboveAxis = ref.aboveAxis;\n    var clipBox = this.owner.pane.clipBox() || box;\n    var horizontalAlign = LEFT;\n    var verticalAlign = TOP;\n    var x, y;\n\n    if (options.vertical) {\n      x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;\n\n      if (aboveAxis) {\n        y = Math.max(box.y1, clipBox.y1);\n      } else {\n        y = Math.min(box.y2, clipBox.y2);\n        verticalAlign = BOTTOM;\n      }\n    } else {\n      var x1 = Math.max(box.x1, clipBox.x1);\n      var x2 = Math.min(box.x2, clipBox.x2);\n\n      if (options.isStacked) {\n        verticalAlign = BOTTOM;\n\n        if (aboveAxis) {\n          horizontalAlign = RIGHT;\n          x = x2;\n        } else {\n          x = x1;\n        }\n\n        y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;\n      } else {\n        if (aboveAxis) {\n          x = x2 + TOOLTIP_OFFSET;\n        } else {\n          x = x1 - TOOLTIP_OFFSET;\n          horizontalAlign = RIGHT;\n        }\n\n        y = Math.max(box.y1, clipBox.y1);\n      }\n    }\n\n    return {\n      point: new Point(x, y),\n      align: {\n        horizontal: horizontalAlign,\n        vertical: verticalAlign\n      }\n    };\n  };\n\n  Bar.prototype.overlapsBox = function overlapsBox(box) {\n    return this.box.overlaps(box);\n  };\n\n  Bar.prototype.pointData = function pointData() {\n    return {\n      dataItem: this.dataItem,\n      category: this.category,\n      value: this.value,\n      percentage: this.percentage,\n      stackValue: this.stackValue,\n      runningTotal: this.runningTotal,\n      total: this.total,\n      series: this.series\n    };\n  };\n\n  return Bar;\n}(ChartElement);\n\ndeepExtend(Bar.prototype, PointEventsMixin);\ndeepExtend(Bar.prototype, NoteMixin);\nBar.prototype.defaults = {\n  border: {\n    width: 1\n  },\n  vertical: true,\n  overlay: {\n    gradient: \"glass\"\n  },\n  labels: {\n    visible: false,\n    format: \"{0}\"\n  },\n  opacity: 1,\n  notes: {\n    label: {}\n  }\n};\nexport default Bar;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar.js"],"names":["drawing","draw","Color","BarLabel","BORDER_BRIGHTNESS","TOOLTIP_OFFSET","hasGradientOverlay","ChartElement","Point","PointEventsMixin","NoteMixin","WHITE","LEFT","RIGHT","BOTTOM","TOP","alignPathToPixel","deepExtend","defined","getTemplate","valueOrDefault","BAR_ALIGN_MIN_WIDTH","Bar","value","options","call","color","aboveAxis","__proto__","prototype","Object","create","constructor","render","_rendered","createLabel","createNote","errorBar","append","labels","visible","pointData","labelTemplate","labelText","formatValue","format","label","vertical","owner","formatPointValue","reflow","targetBox","this$1","box","note","errorBars","i","length","createVisual","ref","customVisual","visual","rectVisual","category","dataItem","sender","getSender","series","percentage","stackValue","runningTotal","total","rect","toRect","group","Group","createRect","width","height","border","strokeOpacity","opacity","size","Math","round","path","Path","fromRect","fill","stroke","getBorderColor","dashType","lineJoin","overlay","createGradientOverlay","baseColor","end","undefined","createHighlight","style","highlight","highlightVisual","highlightVisualArgs","brightness","_brightness","borderColor","toHex","tooltipAnchor","clipBox","pane","horizontalAlign","verticalAlign","x","y","min","x2","max","y1","y2","x1","isStacked","point","align","horizontal","overlapsBox","overlaps","defaults","gradient","notes"],"mappings":"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","sourcesContent":["import { drawing as draw, Color } from '@progress/kendo-drawing';\n\nimport BarLabel from './bar-label';\n\nimport { BORDER_BRIGHTNESS, TOOLTIP_OFFSET } from '../constants';\n\nimport hasGradientOverlay from '../utils/has-gradient-overlay';\n\nimport { ChartElement, Point } from '../../core';\n\nimport PointEventsMixin from '../mixins/point-events-mixin';\nimport NoteMixin from '../mixins/note-mixin';\n\nimport { WHITE, LEFT, RIGHT, BOTTOM, TOP } from '../../common/constants';\nimport { alignPathToPixel, deepExtend, defined, getTemplate, valueOrDefault } from '../../common';\n\nvar BAR_ALIGN_MIN_WIDTH = 6;\n\nvar Bar = (function (ChartElement) {\n    function Bar(value, options) {\n        ChartElement.call(this);\n\n        this.options = options;\n        this.color = options.color || WHITE;\n        this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n        this.value = value;\n    }\n\n    if ( ChartElement ) Bar.__proto__ = ChartElement;\n    Bar.prototype = Object.create( ChartElement && ChartElement.prototype );\n    Bar.prototype.constructor = Bar;\n\n    Bar.prototype.render = function render () {\n        if (this._rendered) {\n            return;\n        }\n\n        this._rendered = true;\n\n        this.createLabel();\n        this.createNote();\n\n        if (this.errorBar) {\n            this.append(this.errorBar);\n        }\n    };\n\n    Bar.prototype.createLabel = function createLabel () {\n        var options = this.options;\n        var labels = options.labels;\n\n        if (labels.visible) {\n            var pointData = this.pointData();\n            var labelTemplate = getTemplate(labels);\n            var labelText;\n\n            if (labelTemplate) {\n                labelText = labelTemplate(pointData);\n            } else {\n                labelText = this.formatValue(labels.format);\n            }\n\n            this.label = new BarLabel(labelText,\n                deepExtend({\n                    vertical: options.vertical\n                },\n                labels\n            ), pointData);\n            this.append(this.label);\n        }\n    };\n\n    Bar.prototype.formatValue = function formatValue (format) {\n        return this.owner.formatPointValue(this, format);\n    };\n\n    Bar.prototype.reflow = function reflow (targetBox) {\n        var this$1 = this;\n\n        this.render();\n\n        var label = this.label;\n\n        this.box = targetBox;\n\n        if (label) {\n            label.options.aboveAxis = this.aboveAxis;\n            label.reflow(targetBox);\n        }\n\n        if (this.note) {\n            this.note.reflow(targetBox);\n        }\n\n        if (this.errorBars) {\n            for (var i = 0; i < this.errorBars.length; i++) {\n                this$1.errorBars[i].reflow(targetBox);\n            }\n        }\n    };\n\n    Bar.prototype.createVisual = function createVisual () {\n        var this$1 = this;\n\n        var ref = this;\n        var box = ref.box;\n        var options = ref.options;\n        var customVisual = options.visual;\n\n        if (this.visible !== false) {\n            ChartElement.prototype.createVisual.call(this);\n\n            if (customVisual) {\n                var visual = this.rectVisual = customVisual({\n                    category: this.category,\n                    dataItem: this.dataItem,\n                    value: this.value,\n                    sender: this.getSender(),\n                    series: this.series,\n                    percentage: this.percentage,\n                    stackValue: this.stackValue,\n                    runningTotal: this.runningTotal,\n                    total: this.total,\n                    rect: box.toRect(),\n                    createVisual: function () {\n                        var group = new draw.Group();\n                        this$1.createRect(group);\n                        return group;\n                    },\n                    options: options\n                });\n\n                if (visual) {\n                    this.visual.append(visual);\n                }\n            } else if (box.width() > 0 && box.height() > 0) {\n                this.createRect(this.visual);\n            }\n        }\n    };\n\n    Bar.prototype.createRect = function createRect (visual) {\n        var options = this.options;\n        var border = options.border;\n        var strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;\n        var rect = this.box.toRect();\n\n        rect.size.width = Math.round(rect.size.width);\n\n        var path = this.rectVisual = draw.Path.fromRect(rect, {\n            fill: {\n                color: this.color,\n                opacity: options.opacity\n            },\n            stroke: {\n                color: this.getBorderColor(),\n                width: border.width,\n                opacity: strokeOpacity,\n                dashType: border.dashType\n            }\n        });\n\n        var width = this.box.width();\n        var height = this.box.height();\n\n        var size = options.vertical ? width : height;\n\n        if (size > BAR_ALIGN_MIN_WIDTH) {\n            alignPathToPixel(path);\n\n            // Fixes lineJoin issue in firefox when the joined lines are parallel\n            if (width < 1 || height < 1) {\n                path.options.stroke.lineJoin = \"round\";\n            }\n        }\n\n        visual.append(path);\n\n        if (hasGradientOverlay(options)) {\n            var overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({\n                end: !options.vertical ? [ 0, 1 ] : undefined\n            }, options.overlay));\n\n            visual.append(overlay);\n        }\n    };\n\n    Bar.prototype.createHighlight = function createHighlight (style) {\n        var highlight = draw.Path.fromRect(this.box.toRect(), style);\n\n        return alignPathToPixel(highlight);\n    };\n\n    Bar.prototype.highlightVisual = function highlightVisual () {\n        return this.rectVisual;\n    };\n\n    Bar.prototype.highlightVisualArgs = function highlightVisualArgs () {\n        return {\n            options: this.options,\n            rect: this.box.toRect(),\n            visual: this.rectVisual\n        };\n    };\n\n    Bar.prototype.getBorderColor = function getBorderColor () {\n        var color = this.color;\n        var border = this.options.border;\n        var brightness = border._brightness || BORDER_BRIGHTNESS;\n        var borderColor = border.color;\n\n        if (!defined(borderColor)) {\n            borderColor = new Color(color).brightness(brightness).toHex();\n        }\n\n        return borderColor;\n    };\n\n    Bar.prototype.tooltipAnchor = function tooltipAnchor () {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.box;\n        var aboveAxis = ref.aboveAxis;\n        var clipBox = this.owner.pane.clipBox() || box;\n        var horizontalAlign = LEFT;\n        var verticalAlign = TOP;\n        var x, y;\n\n        if (options.vertical) {\n            x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;\n            if (aboveAxis) {\n                y = Math.max(box.y1, clipBox.y1);\n            } else {\n                y = Math.min(box.y2, clipBox.y2);\n                verticalAlign = BOTTOM;\n            }\n        } else {\n            var x1 = Math.max(box.x1, clipBox.x1);\n            var x2 = Math.min(box.x2, clipBox.x2);\n\n            if (options.isStacked) {\n                verticalAlign = BOTTOM;\n                if (aboveAxis) {\n                    horizontalAlign = RIGHT;\n                    x = x2;\n                } else {\n                    x = x1;\n                }\n                y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;\n            } else {\n                if (aboveAxis) {\n                    x = x2 + TOOLTIP_OFFSET;\n                } else {\n                    x = x1 - TOOLTIP_OFFSET;\n                    horizontalAlign = RIGHT;\n                }\n                y = Math.max(box.y1, clipBox.y1);\n            }\n        }\n\n        return {\n            point: new Point(x, y),\n            align: {\n                horizontal: horizontalAlign,\n                vertical: verticalAlign\n            }\n        };\n    };\n\n    Bar.prototype.overlapsBox = function overlapsBox (box) {\n        return this.box.overlaps(box);\n    };\n\n    Bar.prototype.pointData = function pointData () {\n        return {\n            dataItem: this.dataItem,\n            category: this.category,\n            value: this.value,\n            percentage: this.percentage,\n            stackValue: this.stackValue,\n            runningTotal: this.runningTotal,\n            total: this.total,\n            series: this.series\n        };\n    };\n\n    return Bar;\n}(ChartElement));\n\ndeepExtend(Bar.prototype, PointEventsMixin);\ndeepExtend(Bar.prototype, NoteMixin);\n\nBar.prototype.defaults = {\n    border: {\n        width: 1\n    },\n    vertical: true,\n    overlay: {\n        gradient: \"glass\"\n    },\n    labels: {\n        visible: false,\n        format: \"{0}\"\n    },\n    opacity: 1,\n    notes: {\n        label: {}\n    }\n};\n\nexport default Bar;"]},"metadata":{},"sourceType":"module"}